% !TeX TXS-program:compile = txs:///knit2pdf
\documentclass[12pt]{mwart}
\usepackage[utf8]{inputenc}
\usepackage[T1,plmath]{polski}
\usepackage{lmodern}

\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[hidelinks]{hyperref}
\usepackage{float}

\title{Sprawozdanie 1}
\author{Aleksander Jakóbczyk i Kacper Pasterniak}
\date{}

\begin{document}
	\maketitle 
	
	<<warning=F, message=F,echo = F>>=
  	library(binom)
    require(ggplot2)
    library(reshape2)
    library(xtable)
	
	  library(vcdExtra)
    library(tidyverse)
  	# pdf.options(encoding = 'ISOLatin2') # znaki polskie w wykresach
	@
	
	\section*{Lista 1}
  \subsection*{Zad 1}
  \subsubsection*{Detergent}
<<size = "small">>=
Detergent.df <- data.frame(Detergent)
Detergent.df %>% group_by(Temperature) %>% summarise(n = sum(Freq))
Detergent.df %>% filter(Water_softness == "Soft") %>% group_by(Temperature) %>% summarise(n = sum(Freq))
Detergent.df %>% filter(Water_softness == "Medium") %>% group_by(Temperature) %>% summarise(n = sum(Freq))
Detergent.df %>% filter(Water_softness == "Hard") %>% group_by(Temperature) %>% summarise(n = sum(Freq))
@

  \subsubsection*{Preference}

  <<size = "small">>=
  # Detergent.df %>% group_by(Preference) %>% summarise(n = sum(Freq))
  Detergent.df %>% filter(Water_softness == "Soft") %>% group_by(Preference) %>% summarise(n = sum(Freq))
  Detergent.df %>% filter(Water_softness == "Medium") %>% group_by(Preference) %>% summarise(n = sum(Freq))
  Detergent.df %>% filter(Water_softness == "Hard") %>% group_by(Preference) %>% summarise(n = sum(Freq))
  @

  \subsection*{Zad 2}
  <<>>=
  ftable(Detergent, col.vars = "Temperature", row.vars = "Water_softness")
  structable(Temperature ~ Water_softness, Detergent) %>% addmargins()
  @

  \subsection*{Zad 3}
<<r fig_1, fig.width = 7, fig.height = 4.5, fig.cap ='\\label{fig:1}Wykresy słupkowy dla zmniennej Water Softness.' ,fig.pos = 'H'>>=
A <- apply(Detergent, "Water_softness", sum)
barplot(A)
@
<<r fig_2, fig.width = 7, fig.height = 4.5, fig.cap ='\\label{fig:2}Wykresy kołowy dla mniennej Water Softness.' ,fig.pos = 'H'>>=
par(mar = c(2, 2, 2, 2))
pie(A)
@
  \subsection*{Zad 4}
<<r fig_3, fig.width = 6, fig.height = 3, fig.cap ='\\label{fig:3}Wykres mozajkowy dla Preference i Water softness' ,fig.pos = 'H'>>=
par(mar = c(2, 2, 2, 2))
mosaicplot(~Water_softness+Preference, data = Detergent)
@
<<r fig_4, fig.width = 6, fig.height = 3, fig.cap ='\\label{fig:4}Wykres mozajkowy dla Preference i M User.' ,fig.pos = 'H'>>=
par(mar = c(2, 2, 2, 2))
mosaicplot(~M_User+Preference, data = Detergent)
@
<<r fig_5, fig.width = 6, fig.height = 3, fig.cap ='\\label{fig:5}Wykres mozajkowy dla Preference i Temperature.' ,fig.pos = 'H'>>=
par(mar = c(2, 2, 2, 2))
mosaicplot(~Temperature+Preference, data = Detergent)
@

\section*{Lista 2}
\subsection*{Zad 1}
\textbf{Losowanie ze zwracaniem:} 
<<>>=
ind <- sample(x=nrow(mtcars),size=nrow(mtcars)/10,replace=TRUE)
@
Wylosowane indeksy:
<<>>=
ind
@
Wylosowane elementy z bazy danych:
<<>>=
mtcars[ind,]
@

\newpage
\textbf{Losowanie bez zwracania:} 
<<>>=
ind <- sample(x=nrow(mtcars),size=nrow(mtcars)/10,replace=FALSE)
@
Wylosowane indeksy:
<<>>=
ind
@
Wylosowane elementy z bazy danych:
<<>>=
mtcars[ind,]
@

\subsection*{Zad 2}
\textbf{Propozycja algorytmu:} \newline
\textbf{1.}Generujemy wektor zer o rozmiarze n \newline
\textbf{2.}Dla każdego elementu tego wektora losujemy u z rozkładu jednostajnego ~U(0,1), jeśli u 	\leqslant p to dodajemy 1 do tego elementu \newline
\textbf{3.}Krok 2 powtarzamy N razy\newline

\textbf{Algorytm opisany za pomocą funkcji w R:}
<<>>=
bin <- function(n,p,N){
  y <- rep(0,n)
  for(j in 1:N){
    for(i in 1:n){
      u <- runif(1)
      if(u <= p){
        y[i] <- 1 + y[i]
      }
    }
  }
  return(y)
}
@
gdzie: n - rozmiar próby, p - prawdopodobieństwo, N - ilość wywołań
\newline
\textbf{Przykładowe użycie:}
<<>>=
bin(10,0.4,5)
@
\newpage
\textbf{Sprawdzenie poprawności:}\newline
Wiemy, że średnia z takie próby powinna wynosić: np,
a wariancja: np(1-p)
<<>>=
test <- bin(1000,0.4,10000)
mean(test)
var(test)
@
Wartości teoretyczne średniej i wariancji dla takich parametrów powinny wynosić kolejno 4000 i 2400. Nasze wyniki są bardzo bliskie co wskazuje na poprawność metody.

\end{document}